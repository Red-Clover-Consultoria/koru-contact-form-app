import { WidgetConfig, AuthResponse, WidgetOptions, CreateElementProps } from './types';
/**
 * Abstract base class for building Koru widgets.
 * Handles authorization, caching, lifecycle management, and provides helper utilities.
 *
 * @example
 * ```typescript
 * class MyWidget extends KoruWidget {
 *   constructor() {
 *     super({ name: 'my-widget', version: '1.0.0' });
 *   }
 *
 *   async onInit(config) {
 *     // Initialize widget state
 *   }
 *
 *   async onRender(config) {
 *     // Render widget UI
 *     this.container = this.createElement('div', {
 *       className: 'my-widget',
 *       children: ['Hello World']
 *     });
 *     document.body.appendChild(this.container);
 *   }
 *
 *   async onDestroy() {
 *     // Cleanup
 *     this.container?.remove();
 *   }
 * }
 *
 * new MyWidget().start();
 * ```
 */
export declare abstract class KoruWidget {
    /** Current widget configuration from Koru */
    protected config: WidgetConfig;
    /** Full authorization response including app and website metadata */
    protected authData: AuthResponse | null;
    /** Main container element for the widget (typically set in onRender) */
    protected container: HTMLElement | null;
    private websiteId;
    private appId;
    private koruUrl;
    private widgetName;
    private widgetVersion;
    private customData;
    private options;
    private isInitialized;
    /**
     * Creates a new widget instance.
     * Extracts configuration from script tag data attributes.
     *
     * @param widgetOptions - Widget configuration including name, version, and options
     * @throws {Error} If script tag or required data attributes are missing
     *
     * @example
     * ```typescript
     * constructor() {
     *   super({
     *     name: 'my-widget',
     *     version: '1.0.0',
     *     options: {
     *       cache: true,
     *       debug: true,
     *       analytics: false
     *     }
     *   });
     * }
     * ```
     */
    constructor(widgetOptions: WidgetOptions);
    /**
     * Starts the widget lifecycle.
     * Waits for DOM, authorizes with Koru, then calls onInit and onRender hooks.
     *
     * @returns Promise that resolves when widget is fully initialized
     * @throws {Error} If authorization fails or lifecycle hooks throw errors
     *
     * @example
     * ```typescript
     * const widget = new MyWidget();
     * await widget.start();
     * ```
     */
    start(): Promise<void>;
    /**
     * Stops the widget and performs cleanup.
     * Calls the onDestroy hook to remove DOM elements and event listeners.
     *
     * @returns Promise that resolves when cleanup is complete
     *
     * @example
     * ```typescript
     * await widget.stop();
     * ```
     */
    stop(): Promise<void>;
    /**
     * Reloads the widget with fresh configuration from Koru.
     * Clears cache and re-authorizes. Calls onConfigUpdate if implemented, otherwise re-renders.
     *
     * @returns Promise that resolves when reload is complete
     *
     * @example
     * ```typescript
     * // Reload widget when configuration changes
     * await widget.reload();
     * ```
     */
    reload(): Promise<void>;
    /**
     * Lifecycle hook called after successful authorization.
     * Use this to initialize widget state, fetch data, or set up event listeners.
     *
     * @param config - Widget configuration from Koru
     * @returns Promise or void
     *
     * @example
     * ```typescript
     * async onInit(config) {
     *   this.apiUrl = config.apiUrl;
     *   this.data = await fetch(this.apiUrl).then(r => r.json());
     * }
     * ```
     */
    protected abstract onInit(config: WidgetConfig): Promise<void> | void;
    /**
     * Lifecycle hook called after onInit to render the widget UI.
     * Create and append DOM elements here.
     *
     * @param config - Widget configuration from Koru
     * @returns Promise or void
     *
     * @example
     * ```typescript
     * async onRender(config) {
     *   this.container = this.createElement('div', {
     *     className: 'my-widget',
     *     children: [this.createElement('h1', { children: [config.title] })]
     *   });
     *   document.body.appendChild(this.container);
     * }
     * ```
     */
    protected abstract onRender(config: WidgetConfig): Promise<void> | void;
    /**
     * Lifecycle hook called when the widget is stopped.
     * Clean up event listeners, timers, and remove DOM elements.
     *
     * @returns Promise or void
     *
     * @example
     * ```typescript
     * async onDestroy() {
     *   clearInterval(this.timer);
     *   this.container?.remove();
     * }
     * ```
     */
    protected abstract onDestroy(): Promise<void> | void;
    /**
     * Optional lifecycle hook called when widget is reloaded.
     * Implement this to update the UI without a full re-render.
     * If not implemented, onDestroy and onRender will be called instead.
     *
     * @param config - Updated widget configuration from Koru
     * @returns Promise or void
     *
     * @example
     * ```typescript
     * async onConfigUpdate(config) {
     *   // Update existing UI elements instead of full re-render
     *   this.titleElement.textContent = config.title;
     * }
     * ```
     */
    protected onConfigUpdate?(config: WidgetConfig): Promise<void> | void;
    private authorize;
    /**
     * Creates a DOM element with the specified tag and properties.
     * Provides a convenient way to build UI elements with type safety.
     *
     * @template K - HTML element tag name
     * @param tag - HTML tag name (e.g., 'div', 'button', 'span')
     * @param props - Element properties including className, style, onClick, and children
     * @returns The created HTML element
     *
     * @example
     * ```typescript
     * // Create a button with click handler
     * const button = this.createElement('button', {
     *   className: 'btn btn-primary',
     *   style: { padding: '10px', backgroundColor: 'blue' },
     *   onClick: () => console.log('clicked'),
     *   children: ['Click Me']
     * });
     *
     * // Create nested elements
     * const card = this.createElement('div', {
     *   className: 'card',
     *   children: [
     *     this.createElement('h2', { children: ['Title'] }),
     *     this.createElement('p', { children: ['Description'] })
     *   ]
     * });
     * ```
     */
    protected createElement<K extends keyof HTMLElementTagNameMap>(tag: K, props?: CreateElementProps<K>): HTMLElementTagNameMap[K];
    /**
     * Detects if the current device is a mobile device.
     * Checks user agent string for common mobile device identifiers.
     *
     * @returns true if mobile device, false otherwise
     *
     * @example
     * ```typescript
     * async onRender(config) {
     *   const layout = this.isMobile() ? 'mobile' : 'desktop';
     *   this.container = this.createElement('div', {
     *     className: `widget-${layout}`
     *   });
     * }
     * ```
     */
    protected isMobile(): boolean;
    /**
     * Tracks an analytics event to Koru.
     * Only sends events if analytics option is enabled.
     *
     * @param eventName - Name of the event to track
     * @param eventData - Optional event metadata
     *
     * @example
     * ```typescript
     * // Track button click
     * this.track('button_clicked', {
     *   button_id: 'cta',
     *   timestamp: Date.now()
     * });
     *
     * // Track page view
     * this.track('page_viewed', {
     *   page: 'home'
     * });
     * ```
     */
    protected track(eventName: string, eventData?: Record<string, unknown>): void;
    /**
     * Logs a debug message to the console.
     * Only logs if debug option is enabled.
     *
     * @param message - Message to log
     * @param args - Additional arguments to log
     *
     * @example
     * ```typescript
     * this.log('Widget initialized', { config: this.config });
     * this.log('Fetching data from', apiUrl);
     * ```
     */
    protected log(message: string, ...args: unknown[]): void;
    private handleError;
    private getCurrentScript;
    private waitForDOM;
    private sleep;
    private getCacheKey;
    private getFromCache;
    private saveToCache;
    private clearCache;
}
//# sourceMappingURL=widget.d.ts.map